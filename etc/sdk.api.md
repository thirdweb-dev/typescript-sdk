## API Report File for "@3rdweb/sdk"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AccessControlEnumerable } from '@3rdweb/contracts';
import { BaseContract } from 'ethers';
import { BigNumber } from 'ethers';
import { BigNumber as BigNumber_2 } from '@ethersproject/bignumber';
import { BigNumberish } from '@ethersproject/bignumber';
import { BigNumberish as BigNumberish_2 } from 'ethers';
import { BytesLike } from 'ethers';
import { CallOverrides } from 'ethers';
import { Coin } from '@3rdweb/contracts';
import { ContractReceipt } from 'ethers';
import { DataStore } from '@3rdweb/contracts';
import { LazyNFT } from '@3rdweb/contracts';
import { Log } from '@ethersproject/providers';
import { Market } from '@3rdweb/contracts';
import type { Network } from '@ethersproject/providers';
import { NFT } from '@3rdweb/contracts';
import { NFTCollection } from '@3rdweb/contracts';
import { Pack } from '@3rdweb/contracts';
import { ProtocolControl } from '@3rdweb/contracts';
import { Provider } from '@ethersproject/providers';
import { Registry } from '@3rdweb/contracts';
import { Signer } from 'ethers';
import { TransactionReceipt } from '@ethersproject/providers';

// Warning: (ae-forgotten-export) The symbol "RegistryModule" needs to be exported by the entry point index.d.ts
// Warning: (ae-internal-missing-underscore) The name "AnyContract" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type AnyContract = typeof AppModule | typeof CollectionModule | typeof NFTModule | typeof CurrencyModule | typeof MarketModule | typeof PackModule | typeof RegistryModule | typeof DropModule | typeof DatastoreModule;

// @public
export class AppModule extends Module<ProtocolControl> {
    // @internal (undocumented)
    protected connectContract(): ProtocolControl;
    // @internal (undocumented)
    getAllContractMetadata(addresses: string[]): Promise<ModuleMetadataNoType[]>;
    getAllModuleMetadata(filterByModuleType?: ModuleType[]): Promise<ModuleMetadata[]>;
    // @deprecated
    getCollectionModules(): Promise<ModuleMetadata[]>;
    // @deprecated
    getCurrencyModules(): Promise<ModuleMetadata[]>;
    // @alpha @deprecated
    getDatastoreModules(): Promise<ModuleMetadata[]>;
    // @deprecated
    getDropModules(): Promise<ModuleMetadata[]>;
    // @deprecated
    getMarketModules(): Promise<ModuleMetadata[]>;
    // @internal (undocumented)
    protected getModuleType(): ModuleType;
    // @deprecated
    getNFTModules(): Promise<ModuleMetadata[]>;
    // @deprecated
    getPackModules(): Promise<ModuleMetadata[]>;
    // (undocumented)
    getRoyaltyTreasury(address?: string): Promise<string>;
    // @deprecated (undocumented)
    setModuleMetadata(metadata: MetadataURIOrObject): Promise<TransactionReceipt>;
    // (undocumented)
    setModuleRoyaltyTreasury(moduleAddress: string, treasury: string): Promise<TransactionReceipt>;
    // (undocumented)
    setRoyaltyTreasury(treasury: string): Promise<TransactionReceipt>;
    // (undocumented)
    withdrawFunds(to: string, currency: string): Promise<TransactionReceipt>;
}

// Warning: (ae-internal-missing-underscore) The name "ChainlinkInfo" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type ChainlinkInfo = {
    vrfCoordinator: string;
    linkTokenAddress: string;
    keyHash: string;
    fees: BigNumber;
};

// Warning: (ae-internal-missing-underscore) The name "ChainlinkVrf" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const ChainlinkVrf: Record<number, ChainlinkInfo>;

// @beta (undocumented)
export interface CollectionMetadata {
    // (undocumented)
    creator: string;
    // (undocumented)
    metadata: NFTMetadata;
    // (undocumented)
    ownedByAddress: number;
    // (undocumented)
    supply: BigNumber_2;
}

// @beta
export class CollectionModule extends ModuleWithRoles<NFTCollection> {
    // (undocumented)
    balance(tokenId: string): Promise<BigNumber_2>;
    // (undocumented)
    balanceOf(address: string, tokenId: string): Promise<BigNumber_2>;
    // (undocumented)
    burn(args: INFTCollectionBatchArgs): Promise<TransactionReceipt>;
    // (undocumented)
    burnBatch(args: INFTCollectionBatchArgs[]): Promise<TransactionReceipt>;
    // (undocumented)
    burnBatchFrom(account: string, args: INFTCollectionBatchArgs[]): Promise<TransactionReceipt>;
    // (undocumented)
    burnFrom(account: string, args: INFTCollectionBatchArgs): Promise<TransactionReceipt>;
    // @internal (undocumented)
    protected connectContract(): NFTCollection;
    // (undocumented)
    create(metadata: MetadataURIOrObject): Promise<CollectionMetadata>;
    // (undocumented)
    createAndMint(metadataWithSupply: INFTCollectionCreateArgs): Promise<CollectionMetadata>;
    // (undocumented)
    createAndMintBatch(metadataWithSupply: INFTCollectionCreateArgs[]): Promise<CollectionMetadata[]>;
    // (undocumented)
    createBatch(metadatas: MetadataURIOrObject[]): Promise<CollectionMetadata[]>;
    // (undocumented)
    createWithERC20(tokenContract: string, tokenAmount: BigNumberish, args: INFTCollectionCreateArgs): Promise<void>;
    // (undocumented)
    createWithERC721(tokenContract: string, tokenId: BigNumberish, metadata: MetadataURIOrObject): Promise<void>;
    get(tokenId: string, address?: string): Promise<CollectionMetadata>;
    getAll(address?: string): Promise<CollectionMetadata[]>;
    // @internal @override (undocumented)
    protected getModuleRoles(): readonly Role[];
    // @internal (undocumented)
    protected getModuleType(): ModuleType;
    getOwned(_address?: string): Promise<CollectionMetadata[]>;
    // (undocumented)
    isApproved(address: string, operator: string): Promise<boolean>;
    // (undocumented)
    mint(args: INFTCollectionBatchArgs): Promise<void>;
    // (undocumented)
    mintBatch(args: INFTCollectionBatchArgs[]): Promise<void>;
    // (undocumented)
    mintBatchTo(to: string, args: INFTCollectionBatchArgs[], data?: BytesLike): Promise<void>;
    // (undocumented)
    mintTo(to: string, args: INFTCollectionBatchArgs, data?: BytesLike): Promise<void>;
    // (undocumented)
    static moduleType: ModuleType;
    // (undocumented)
    static roles: readonly ["admin", "minter", "pauser", "transfer"];
    // (undocumented)
    setApproval(operator: string, approved?: boolean): Promise<TransactionReceipt>;
    // (undocumented)
    setModuleMetadata(metadata: MetadataURIOrObject): Promise<TransactionReceipt>;
    // (undocumented)
    setRestrictedTransfer(restricted?: boolean): Promise<TransactionReceipt>;
    // (undocumented)
    setRoyaltyBps(amount: number): Promise<TransactionReceipt>;
    // (undocumented)
    transfer(to: string, tokenId: string, amount: BigNumberish): Promise<TransactionReceipt>;
    // (undocumented)
    transferBatchFrom(from: string, to: string, args: INFTCollectionBatchArgs[], data?: BytesLike): Promise<TransactionReceipt>;
    // (undocumented)
    transferFrom(from: string, to: string, args: INFTCollectionBatchArgs, data?: BytesLike): Promise<TransactionReceipt>;
}

// @public
export interface ContractMetadata {
    // (undocumented)
    description?: string;
    // (undocumented)
    external_link?: string;
    // (undocumented)
    fee_recipient?: string;
    // (undocumented)
    image?: string;
    // (undocumented)
    name?: string;
    // (undocumented)
    seller_fee_basis_points?: number;
    // (undocumented)
    uri: string;
}

// @public (undocumented)
export function convertModuleTypeToName(moduleType: ModuleType): keyof typeof ModuleType | undefined;

// @public (undocumented)
export function convertNameToModuleType(moduleName?: string): ModuleType | undefined;

// @beta (undocumented)
export interface CreatePublicMintCondition {
    // (undocumented)
    currency?: string;
    // (undocumented)
    maxMintSupply: BigNumberish_2;
    // (undocumented)
    merkleRoot?: BytesLike;
    // (undocumented)
    pricePerToken?: BigNumberish_2;
    // (undocumented)
    quantityLimitPerTransaction?: BigNumberish_2;
    // (undocumented)
    startTimestampInSeconds?: BigNumberish_2;
    // (undocumented)
    waitTimeSecondsLimitPerTransaction?: BigNumberish_2;
}

// @public
export interface Currency {
    // (undocumented)
    decimals: number;
    // (undocumented)
    name: string;
    // (undocumented)
    symbol: string;
}

// @public
export class CurrencyModule extends ModuleWithRoles<Coin> {
    // (undocumented)
    allowance(spender: string): Promise<BigNumber>;
    // (undocumented)
    allowanceOf(owner: string, spender: string): Promise<BigNumber>;
    // (undocumented)
    balance(): Promise<CurrencyValue>;
    // (undocumented)
    balanceOf(address: string): Promise<CurrencyValue>;
    // (undocumented)
    burn(amount: BigNumberish_2): Promise<TransactionReceipt>;
    // (undocumented)
    burnFrom(from: string, amount: BigNumberish_2): Promise<TransactionReceipt>;
    // @internal (undocumented)
    protected connectContract(): Coin;
    // (undocumented)
    get(): Promise<Currency>;
    // @internal @override (undocumented)
    protected getModuleRoles(): readonly Role[];
    // @internal (undocumented)
    protected getModuleType(): ModuleType;
    // (undocumented)
    getValue(value: BigNumberish_2): Promise<CurrencyValue>;
    // (undocumented)
    mint(amount: BigNumberish_2): Promise<void>;
    // (undocumented)
    mintTo(to: string, amount: BigNumberish_2): Promise<void>;
    // (undocumented)
    static moduleType: ModuleType;
    // (undocumented)
    static roles: readonly ["admin", "minter", "pauser", "transfer"];
    // (undocumented)
    setAllowance(spender: string, amount: BigNumber): Promise<TransactionReceipt>;
    // (undocumented)
    setModuleMetadata(metadata: MetadataURIOrObject): Promise<TransactionReceipt>;
    // (undocumented)
    setRestrictedTransfer(restricted?: boolean): Promise<TransactionReceipt>;
    // (undocumented)
    totalSupply(): Promise<BigNumber>;
    // (undocumented)
    transfer(to: string, amount: BigNumber): Promise<TransactionReceipt>;
    // (undocumented)
    transferFrom(from: string, to: string, amount: BigNumberish_2): Promise<TransactionReceipt>;
}

// @public
export interface CurrencyValue extends Currency {
    // (undocumented)
    displayValue: string;
    // (undocumented)
    value: string;
}

// @alpha
export class DatastoreModule extends ModuleWithRoles<DataStore> {
    // @internal (undocumented)
    protected connectContract(): DataStore;
    // @internal @override (undocumented)
    protected getModuleRoles(): readonly Role[];
    // @internal (undocumented)
    protected getModuleType(): ModuleType;
    // (undocumented)
    getUint(key: string): Promise<BigNumberish_2 | undefined>;
    // (undocumented)
    static moduleType: ModuleType;
    // (undocumented)
    static roles: readonly ["admin", "editor"];
    // (undocumented)
    setUint(key: string, value: BigNumberish_2): Promise<TransactionReceipt>;
}

// @beta
export class DropModule extends ModuleWithRoles<LazyNFT> {
    // (undocumented)
    balance(): Promise<BigNumber>;
    // (undocumented)
    balanceOf(address: string): Promise<BigNumber>;
    // (undocumented)
    burn(tokenId: BigNumberish_2): Promise<TransactionReceipt>;
    // (undocumented)
    claim(quantity: BigNumberish_2): Promise<void>;
    // @internal (undocumented)
    protected connectContract(): LazyNFT;
    // (undocumented)
    get(tokenId: string): Promise<NFTMetadataOwner>;
    // (undocumented)
    getActiveMintCondition(): Promise<PublicMintCondition>;
    // (undocumented)
    getAll(): Promise<NFTMetadataOwner[]>;
    // (undocumented)
    getAllClaimed(): Promise<NFTMetadataOwner[]>;
    // (undocumented)
    getAllMintConditions(): Promise<PublicMintCondition[]>;
    // (undocumented)
    getAllUnclaimed(): Promise<NFTMetadataOwner[]>;
    // @internal @override (undocumented)
    protected getModuleRoles(): readonly Role[];
    // @internal (undocumented)
    protected getModuleType(): ModuleType;
    // (undocumented)
    getOwned(_address?: string): Promise<NFTMetadataOwner[]>;
    // (undocumented)
    isApproved(address: string, operator: string): Promise<boolean>;
    // (undocumented)
    lazyMint(metadata: MetadataURIOrObject): Promise<void>;
    // (undocumented)
    lazyMintAmount(amount: BigNumberish_2): Promise<void>;
    // (undocumented)
    lazyMintBatch(metadatas: MetadataURIOrObject[]): Promise<void>;
    // (undocumented)
    maxTotalSupply(): Promise<BigNumber>;
    // (undocumented)
    static moduleType: ModuleType;
    // (undocumented)
    ownerOf(tokenId: string): Promise<string>;
    // (undocumented)
    static roles: readonly ["admin", "minter", "pauser", "transfer"];
    // (undocumented)
    setApproval(operator: string, approved?: boolean): Promise<TransactionReceipt>;
    // (undocumented)
    setBaseTokenUri(uri: string): Promise<TransactionReceipt>;
    // (undocumented)
    setMaxTotalSupply(amount: BigNumberish_2): Promise<TransactionReceipt>;
    // (undocumented)
    setModuleMetadata(metadata: MetadataURIOrObject): Promise<TransactionReceipt>;
    // (undocumented)
    setPublicMintConditions(conditions: CreatePublicMintCondition[]): Promise<void>;
    // (undocumented)
    setRestrictedTransfer(restricted: boolean): Promise<TransactionReceipt>;
    // (undocumented)
    setRoyaltyBps(amount: number): Promise<TransactionReceipt>;
    // (undocumented)
    totalClaimedSupply(): Promise<BigNumber>;
    // (undocumented)
    totalSupply(): Promise<BigNumber>;
    // (undocumented)
    totalUnclaimedSupply(): Promise<BigNumber>;
    // (undocumented)
    transfer(to: string, tokenId: string): Promise<TransactionReceipt>;
    // (undocumented)
    transferFrom(from: string, to: string, tokenId: BigNumberish_2): Promise<TransactionReceipt>;
}

// @public
export type ForwardRequestMessage = {
    from: string;
    to: string;
    value: string;
    gas: string;
    nonce: string;
    data: BytesLike;
};

// Warning: (ae-internal-missing-underscore) The name "getContractMetadata" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function getContractMetadata(provider: ProviderOrSigner, address: string, ipfsGatewayUrl: string): Promise<ContractMetadata>;

// Warning: (ae-internal-missing-underscore) The name "getCurrencyMetadata" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function getCurrencyMetadata(providerOrSigner: ProviderOrSigner, asset: string): Promise<Currency>;

// Warning: (ae-internal-missing-underscore) The name "getCurrencyValue" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function getCurrencyValue(providerOrSigner: ProviderOrSigner, asset: string, price: BigNumber): Promise<CurrencyValue>;

// Warning: (ae-internal-missing-underscore) The name "getGasPriceForChain" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function getGasPriceForChain(chainId: number, speed: string, maxGasPrice: number): Promise<number | null>;

// Warning: (ae-internal-missing-underscore) The name "getMetadataWithoutContract" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function getMetadataWithoutContract(provider: ProviderOrSigner, contractAddress: string, tokenId: string, ipfsGatewayUrl: string): Promise<NFTMetadata>;

// Warning: (ae-internal-missing-underscore) The name "getRoleHash" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function getRoleHash(role: Role): BytesLike;

// Warning: (ae-internal-missing-underscore) The name "getTokenMetadata" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function getTokenMetadata(contract: NFTContractTypes, tokenId: string, ipfsGatewayUrl: string): Promise<NFTMetadata>;

// Warning: (ae-internal-missing-underscore) The name "getTokenUri" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function getTokenUri(contract: NFTContractTypes, tokenId: string): Promise<string>;

// @public (undocumented)
export interface IAppModule {
    // (undocumented)
    address: string;
    // (undocumented)
    metadata?: ContractMetadata;
    // (undocumented)
    version: number;
}

// @beta (undocumented)
export interface INFTCollectionBatchArgs {
    // (undocumented)
    amount: BigNumberish;
    // (undocumented)
    tokenId: BigNumberish;
}

// @beta (undocumented)
export interface INFTCollectionCreateArgs {
    // (undocumented)
    metadata: MetadataURIOrObject;
    // (undocumented)
    supply: BigNumberish;
}

// Warning: (ae-internal-missing-underscore) The name "InterfaceId_IERC1155" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const InterfaceId_IERC1155: Uint8Array;

// Warning: (ae-internal-missing-underscore) The name "InterfaceId_IERC721" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const InterfaceId_IERC721: Uint8Array;

// @public
export class InvariantError extends Error {
    // @internal
    constructor(message?: string);
    // @internal (undocumented)
    framesToPop: number;
    // @internal (undocumented)
    name: string;
}

// @beta (undocumented)
export interface IPackBatchArgs {
    // (undocumented)
    amount: BigNumberish_2;
    // (undocumented)
    tokenId: BigNumberish_2;
}

// @beta (undocumented)
export interface IPackCreateArgs {
    // (undocumented)
    assetContract: string;
    // (undocumented)
    assets: {
        tokenId: BigNumberish_2;
        amount: BigNumberish_2;
    }[];
    // (undocumented)
    metadata: MetadataURIOrObject;
    // (undocumented)
    rewardsPerOpen?: number;
    // (undocumented)
    secondsUntilOpenStart?: number;
}

// @public
export interface IRoles {
    admin: "admin";
    // @alpha
    editor: "editor";
    lister: "lister";
    minter: "minter";
    pauser: "pauser";
    transfer: "transfer";
}

// Warning: (ae-internal-missing-underscore) The name "isContract" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function isContract(provider: Provider, address: string): Promise<boolean>;

// @public
export interface ISDKOptions {
    gasSpeed: string;
    ipfsGatewayUrl: string;
    maxGasPriceInGwei: number;
    readOnlyRpcUrl: string;
    registryContractAddress: string;
    transactionRelayerForwarderAddress: string;
    transactionRelayerSendFunction: (message: ForwardRequestMessage, signature: BytesLike) => Promise<string>;
    transactionRelayerUrl: string;
}

// @public
export type JSONValue = string | number | null | boolean | JSONValue[] | {
    [key: string]: JSONValue;
};

// @public
export interface ListingFilter {
    // (undocumented)
    seller?: string;
    // (undocumented)
    tokenContract?: string;
    // (undocumented)
    tokenId?: string;
}

// @public
export interface ListingMetadata {
    // (undocumented)
    currencyContract: string;
    // (undocumented)
    currencyMetadata: CurrencyValue | null;
    // (undocumented)
    id: string;
    // (undocumented)
    price: BigNumber;
    // (undocumented)
    quantity: BigNumber;
    // (undocumented)
    saleEnd: Date | null;
    // (undocumented)
    saleStart: Date | null;
    // (undocumented)
    seller: string;
    // (undocumented)
    tokenContract: string;
    // (undocumented)
    tokenId: string;
    // (undocumented)
    tokenMetadata?: NFTMetadata;
}

// @public
export class MarketModule extends ModuleWithRoles<Market> {
    // (undocumented)
    buy(listingId: string, quantity: BigNumberish_2): Promise<ListingMetadata>;
    // @internal (undocumented)
    protected connectContract(): Market;
    // (undocumented)
    get(listingId: string): Promise<ListingMetadata>;
    // (undocumented)
    getAll(filter?: ListingFilter): Promise<ListingMetadata[]>;
    // @deprecated (undocumented)
    getAllListings(filter?: ListingFilter): Promise<ListingMetadata[]>;
    // @deprecated (undocumented)
    getListing(listingId: string): Promise<ListingMetadata>;
    // (undocumented)
    getMarketFeeBps(): Promise<BigNumber>;
    // @internal @override (undocumented)
    protected getModuleRoles(): readonly Role[];
    // @internal (undocumented)
    protected getModuleType(): ModuleType;
    // (undocumented)
    list(assetContract: string, tokenId: string, currencyContract: string, price: BigNumberish_2, quantity: BigNumberish_2, tokensPerBuyer?: BigNumberish_2, secondsUntilStart?: BigNumberish_2, secondsUntilEnd?: BigNumberish_2): Promise<ListingMetadata>;
    // (undocumented)
    static moduleType: ModuleType;
    // (undocumented)
    static roles: readonly ["admin", "lister", "pauser"];
    // (undocumented)
    setMarketFeeBps(fee: number): Promise<TransactionReceipt>;
    // (undocumented)
    setModuleMetadata(metadata: MetadataURIOrObject): Promise<TransactionReceipt>;
    // (undocumented)
    unlist(listingId: string, quantity: BigNumberish_2): Promise<void>;
    // (undocumented)
    unlistAll(listingId: string): Promise<void>;
}

// @public
export type MetadataURIOrObject = string | Record<string, JSONValue>;

// @public
export class Module<TContract extends BaseContract = BaseContract> {
    // @internal
    constructor(providerOrSigner: ProviderOrSigner, address: string, options: ISDKOptions);
    // (undocumented)
    readonly address: string;
    // @internal (undocumented)
    clearSigner(): void;
    // @internal @virtual (undocumented)
    protected connectContract(): TContract;
    // @internal
    contract: TContract;
    // (undocumented)
    exists(): Promise<boolean>;
    // @internal (undocumented)
    protected getCallOverrides(): Promise<CallOverrides>;
    // @internal (undocumented)
    protected getChainID(): Promise<number>;
    getMetadata(): Promise<ModuleMetadata>;
    // @internal @virtual (undocumented)
    protected getModuleType(): ModuleType;
    // @internal (undocumented)
    protected getProvider(): Promise<Provider | undefined>;
    // @internal (undocumented)
    protected getSigner(): Signer | null;
    // @internal (undocumented)
    protected getSignerAddress(): Promise<string>;
    // @internal (undocumented)
    protected hasValidSigner(): boolean;
    // @internal (undocumented)
    protected readonly ipfsGatewayUrl: string;
    // @internal (undocumented)
    protected readonly options: ISDKOptions;
    // (undocumented)
    protected parseEventLogs(eventName: string, logs?: Log[]): any;
    // @internal (undocumented)
    protected get providerOrSigner(): ProviderOrSigner;
    // @internal
    readOnlyContract: TContract;
    // @internal (undocumented)
    protected sendTransaction(fn: string, args: any[], callOverrides?: CallOverrides): Promise<TransactionReceipt>;
    setMetadata(metadata: MetadataURIOrObject): Promise<ModuleMetadata>;
    // @internal (undocumented)
    setProviderOrSigner(providerOrSigner: ProviderOrSigner): void;
    // @internal (undocumented)
    protected get signer(): Signer | null;
}

// @public
export interface ModuleMetadata extends ModuleMetadataNoType {
    // (undocumented)
    type: ModuleType;
}

// @public @deprecated
export interface ModuleMetadataNoType {
    // (undocumented)
    address: string;
    // (undocumented)
    metadata?: ContractMetadata;
}

// @public
export enum ModuleType {
    // (undocumented)
    ACCESS_NFT = 4,
    // (undocumented)
    COLLECTION = 1,
    // (undocumented)
    CURRENCY = 0,
    // (undocumented)
    DATASTORE = 8,
    // (undocumented)
    DROP = 7,
    // (undocumented)
    DYNAMIC_NFT = 3,
    // (undocumented)
    MARKET = 6,
    // (undocumented)
    NFT = 2,
    // (undocumented)
    PACK = 5
}

// @public
export class ModuleWithRoles<TContract extends AccessControlEnumerable = AccessControlEnumerable> extends Module<TContract> {
    // @internal
    constructor(providerOrSigner: ProviderOrSigner, address: string, options: ISDKOptions);
    getAllRoleMembers(): Promise<Partial<Record<Role, string[]>>>;
    // @internal @virtual (undocumented)
    protected getModuleRoles(): readonly Role[];
    getRoleMembers(role: Role): Promise<string[]>;
    grantRole(role: Role, address: string): Promise<TransactionReceipt>;
    revokeRole(role: Role, address: string): Promise<TransactionReceipt>;
}

// Warning: (ae-internal-missing-underscore) The name "NFTContractTypes" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type NFTContractTypes = NFT | NFTCollection | LazyNFT;

// @public @deprecated
export const NFTLabsSDK: typeof ThirdwebSDK;

// @public
export interface NFTMetadata {
    // (undocumented)
    description?: string;
    // (undocumented)
    id: string;
    // (undocumented)
    image?: string;
    // (undocumented)
    name?: string;
    // (undocumented)
    properties?: Record<string, JSONValue>;
    // (undocumented)
    uri: string;
}

// @public
export interface NFTMetadataOwner {
    // (undocumented)
    metadata: NFTMetadata;
    // (undocumented)
    owner: string;
}

// @public
export class NFTModule extends ModuleWithRoles<NFT> {
    // (undocumented)
    balance(): Promise<BigNumber>;
    // (undocumented)
    balanceOf(address: string): Promise<BigNumber>;
    // (undocumented)
    burn(tokenId: BigNumberish_2): Promise<TransactionReceipt>;
    // @internal (undocumented)
    protected connectContract(): NFT;
    // (undocumented)
    get(tokenId: string): Promise<NFTMetadata>;
    // (undocumented)
    getAll(): Promise<NFTMetadata[]>;
    // (undocumented)
    getAllWithOwner(): Promise<NFTMetadataOwner[]>;
    // (undocumented)
    protected getModuleRoles(): readonly Role[];
    // @internal (undocumented)
    protected getModuleType(): ModuleType;
    // (undocumented)
    getOwned(_address?: string): Promise<NFTMetadata[]>;
    // (undocumented)
    getWithOwner(tokenId: string): Promise<NFTMetadataOwner>;
    // (undocumented)
    isApproved(address: string, operator: string): Promise<boolean>;
    // (undocumented)
    mint(metadata: MetadataURIOrObject): Promise<NFTMetadata>;
    // (undocumented)
    mintBatch(metadatas: MetadataURIOrObject[]): Promise<NFTMetadata[]>;
    // (undocumented)
    mintBatchTo(to: string, metadatas: MetadataURIOrObject[]): Promise<NFTMetadata[]>;
    // (undocumented)
    mintTo(to: string, metadata: MetadataURIOrObject): Promise<NFTMetadata>;
    // (undocumented)
    static moduleType: ModuleType;
    ownerOf(tokenId: string): Promise<string>;
    // (undocumented)
    static roles: readonly ["admin", "minter", "pauser", "transfer"];
    // (undocumented)
    setApproval(operator: string, approved?: boolean): Promise<TransactionReceipt>;
    // (undocumented)
    setModuleMetadata(metadata: MetadataURIOrObject): Promise<TransactionReceipt>;
    // (undocumented)
    setRestrictedTransfer(restricted?: boolean): Promise<TransactionReceipt>;
    // (undocumented)
    setRoyaltyBps(amount: number): Promise<TransactionReceipt>;
    // (undocumented)
    totalSupply(): Promise<BigNumber>;
    // (undocumented)
    transfer(to: string, tokenId: string): Promise<TransactionReceipt>;
    // (undocumented)
    transferFrom(from: string, to: string, tokenId: BigNumberish_2): Promise<TransactionReceipt>;
}

// @public
export class NotFoundError extends Error {
    // @internal
    constructor();
}

// @beta (undocumented)
export interface PackMetadata {
    // (undocumented)
    creator: string;
    // (undocumented)
    currentSupply: BigNumber;
    // (undocumented)
    id: string;
    // (undocumented)
    metadata: NFTMetadata;
    // (undocumented)
    openStart: Date | null;
}

// @beta
export class PackModule extends ModuleWithRoles<Pack> {
    // (undocumented)
    balance(tokenId: string): Promise<BigNumber>;
    // (undocumented)
    balanceOf(address: string, tokenId: string): Promise<BigNumber>;
    // @internal (undocumented)
    protected connectContract(): Pack;
    // (undocumented)
    create(args: IPackCreateArgs): Promise<PackMetadata>;
    // (undocumented)
    depositLink(amount: BigNumberish_2): Promise<void>;
    // (undocumented)
    get(packId: string): Promise<PackMetadata>;
    // (undocumented)
    getAll(): Promise<PackMetadata[]>;
    // (undocumented)
    getLinkBalance(): Promise<CurrencyValue>;
    // @internal @override (undocumented)
    protected getModuleRoles(): readonly Role[];
    // @internal (undocumented)
    protected getModuleType(): ModuleType;
    // (undocumented)
    getNFTs(packId: string): Promise<PackNFTMetadata[]>;
    // (undocumented)
    isApproved(address: string, operator: string): Promise<boolean>;
    // (undocumented)
    static moduleType: ModuleType;
    // (undocumented)
    open(packId: string): Promise<NFTMetadata[]>;
    // (undocumented)
    static roles: readonly ["admin", "minter", "pauser", "transfer"];
    // (undocumented)
    setApproval(operator: string, approved?: boolean): Promise<void>;
    // (undocumented)
    setModuleMetadata(metadata: MetadataURIOrObject): Promise<void>;
    // (undocumented)
    setRestrictedTransfer(restricted?: boolean): Promise<void>;
    // (undocumented)
    setRoyaltyBps(amount: number): Promise<void>;
    // (undocumented)
    transfer(to: string, tokenId: string, amount: BigNumber): Promise<void>;
    // (undocumented)
    transferBatchFrom(from: string, to: string, args: IPackBatchArgs[], data?: BytesLike): Promise<void>;
    // (undocumented)
    transferFrom(from: string, to: string, args: IPackBatchArgs, data?: BytesLike): Promise<void>;
    // (undocumented)
    withdrawLink(to: string, amount: BigNumberish_2): Promise<void>;
}

// @public (undocumented)
export interface PackNFTMetadata {
    // (undocumented)
    metadata: NFTMetadata;
    // (undocumented)
    supply: BigNumber;
}

// @public
export type ProviderOrSigner = Provider | Signer;

// @beta (undocumented)
export interface PublicMintCondition {
    // (undocumented)
    currency: string;
    // (undocumented)
    currentMintSupply: BigNumberish_2;
    // (undocumented)
    maxMintSupply: BigNumberish_2;
    // (undocumented)
    merkleRoot: BytesLike;
    // (undocumented)
    pricePerToken: BigNumberish_2;
    // (undocumented)
    quantityLimitPerTransaction: BigNumberish_2;
    // (undocumented)
    startTimestamp: BigNumberish_2;
    // (undocumented)
    waitTimeSecondsLimitPerTransaction: BigNumberish_2;
}

// Warning: (ae-internal-missing-underscore) The name "replaceIpfsWithGateway" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function replaceIpfsWithGateway(ipfsUrl: string, gatewayUrl: string): string;

// @public
export type Role = keyof IRoles;

// Warning: (ae-internal-missing-underscore) The name "RolesMap" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const RolesMap: IRoles;

// @public
export class ThirdwebSDK {
    constructor(providerOrNetwork: ValidProviderInput, opts?: Partial<ISDKOptions>);
    createApp(metadata: MetadataURIOrObject): Promise<ContractReceipt>;
    // (undocumented)
    getAppModule(address: string): AppModule;
    getApps(): Promise<IAppModule[]>;
    // Warning: (ae-incompatible-release-tags) The symbol "getCollectionModule" is marked as @public, but its signature references "CollectionModule" which is marked as @beta
    //
    // (undocumented)
    getCollectionModule(address: string): CollectionModule;
    // (undocumented)
    getContractMetadata(address: string): Promise<ModuleMetadataNoType>;
    // (undocumented)
    getCurrencyModule(address: string): CurrencyModule;
    // @alpha (undocumented)
    getDatastoreModule(address: string): DatastoreModule;
    // Warning: (ae-incompatible-release-tags) The symbol "getDropModule" is marked as @public, but its signature references "DropModule" which is marked as @beta
    //
    // (undocumented)
    getDropModule(address: string): DropModule;
    // @internal
    getForwarderAddress(): Promise<string>;
    // (undocumented)
    getGasPrice(speed?: string, maxGasGwei?: number): Promise<number | null>;
    // (undocumented)
    getMarketModule(address: string): MarketModule;
    // (undocumented)
    getNFTModule(address: string): NFTModule;
    // Warning: (ae-incompatible-release-tags) The symbol "getPackModule" is marked as @public, but its signature references "PackModule" which is marked as @beta
    //
    // (undocumented)
    getPackModule(address: string): PackModule;
    // (undocumented)
    isReadOnly(): boolean;
    // (undocumented)
    setProviderOrSigner(providerOrSignerOrNetwork: ValidProviderInput): ProviderOrSigner;
    // @internal
    get signer(): Signer | null;
}

// Warning: (ae-internal-missing-underscore) The name "uploadMetadata" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function uploadMetadata(metadata: MetadataURIOrObject, contractAddress?: string, signerAddress?: string): Promise<string>;

// @public
export function uploadToIPFS(data: string | File, contractAddress?: string, signerAddress?: string): Promise<string>;

// @public
export type ValidProviderInput = ProviderOrSigner | Network | string;

```
