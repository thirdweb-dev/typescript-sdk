{
  "DropErc1155Contract": {
    "name": "DropErc1155Contract",
    "summary": "Setup a collection of NFTs with a customizable number of each NFT that are minted as users claim them.\n\n",
    "remarks": null,
    "examples": {
      "javascript": "import { ThirdwebSDK } from \"@3rdweb/sdk\";\n\n// You can switch out this provider with any wallet or provider setup you like.\nconst provider = ethers.Wallet.createRandom();\nconst sdk = new ThirdwebSDK(provider);\nconst contract = sdk.getBundleDropContract(\"{{contract_address}}\");"
    },
    "methods": [
      {
        "name": "claimTo",
        "summary": "Claim NFTs to a specific Wallet\n\n",
        "remarks": "\n\nLet the specified wallet claim NFTs.\n\n",
        "examples": {
          "javascript": "const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\nconst tokenId = 0; // the id of the NFT you want to claim\nconst quantity = 1; // how many NFTs you want to claim\n\nconst tx = await contract.claimTo(address, quantity);\nconst receipt = tx.receipt; // the transaction receipt\nconst claimedTokenId = tx.id; // the id of the NFT claimed\nconst claimedNFT = await tx.data(); // (optional) get the claimed NFT metadata"
        },
        "signature": "claimTo(destinationAddress: string, tokenId: BigNumberish, quantity: BigNumberish, proofs?: BytesLike[]): Promise<TransactionResult>;"
      },
      {
        "name": "createBatch",
        "summary": "Create a batch of NFTs to be claimed in the future\n\n",
        "remarks": "\n\nCreate batch allows you to create a batch of many NFTs in one transaction.\n\n",
        "examples": {
          "javascript": "// Custom metadata of the NFTs to create\nconst metadatas = [{\n  name: \"Cool NFT\",\n  description: \"This is a cool NFT\",\n  image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n}, {\n  name: \"Cool NFT\",\n  description: \"This is a cool NFT\",\n  image: fs.readFileSync(\"path/to/image.png\"),\n}];\n\nconst results = await contract.createBatch(metadatas); // uploads and creates the NFTs on chain\nconst firstTokenId = results[0].id; // token id of the first created NFT\nconst firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT"
        },
        "signature": "createBatch(metadatas: NFTMetadataInput[]): Promise<TransactionResultWithId<NFTMetadata>[]>;"
      }
    ],
    "signature": "declare class DropErc1155Contract extends Erc1155<DropERC1155> "
  },
  "DropErc721Contract": {
    "name": "DropErc721Contract",
    "summary": "Setup a collection of one-of-one NFTs that are minted as users claim them.\n\n",
    "remarks": null,
    "examples": {
      "javascript": "import { ThirdwebSDK } from \"@3rdweb/sdk\";\n\n// You can switch out this provider with any wallet or provider setup you like.\nconst provider = ethers.Wallet.createRandom();\nconst sdk = new ThirdwebSDK(provider);\nconst contract = sdk.getDropContract(\"{{contract_address}}\");"
    },
    "methods": [
      {
        "name": "claimTo",
        "summary": "Claim unique NFTs to a specific Wallet\n\n",
        "remarks": "\n\nLet the specified wallet claim NFTs.\n\n",
        "examples": {
          "javascript": "const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\nconst quantity = 1; // how many unique NFTs you want to claim\n\nconst tx = await contract.claimTo(address, quantity);\nconst receipt = tx.receipt; // the transaction receipt\nconst claimedTokenId = tx.id; // the id of the NFT claimed\nconst claimedNFT = await tx.data(); // (optional) get the claimed NFT metadata"
        },
        "signature": "claimTo(destinationAddress: string, quantity: BigNumberish, proofs?: BytesLike[]): Promise<TransactionResultWithId<NFTMetadataOwner>[]>;"
      },
      {
        "name": "createBatch",
        "summary": "Create a batch of unique NFTs to be claimed in the future\n\n",
        "remarks": "\n\nCreate batch allows you to create a batch of many unique NFTs in one transaction.\n\n",
        "examples": {
          "javascript": "// Custom metadata of the NFTs to create\nconst metadatas = [{\n  name: \"Cool NFT\",\n  description: \"This is a cool NFT\",\n  image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n}, {\n  name: \"Cool NFT\",\n  description: \"This is a cool NFT\",\n  image: fs.readFileSync(\"path/to/image.png\"),\n}];\n\nconst results = await contract.createBatch(metadatas); // uploads and creates the NFTs on chain\nconst firstTokenId = results[0].id; // token id of the first created NFT\nconst firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT"
        },
        "signature": "createBatch(metadatas: NFTMetadataInput[]): Promise<TransactionResultWithId<NFTMetadata>[]>;"
      },
      {
        "name": "getAllClaimed",
        "summary": "Get All Claimed NFTs\n\n",
        "remarks": "\n\nFetch all the NFTs (and their owners) that have been claimed in this Drop.\n\n*\n\n",
        "examples": {
          "javascript": "const claimedNFTs = await contract.getAllClaimed();\nconst firstOwner = claimedNFTs[0].owner;"
        },
        "signature": "getAllClaimed(queryParams?: QueryAllParams): Promise<NFTMetadataOwner[]>;"
      },
      {
        "name": "getAllUnclaimed",
        "summary": "Get All Unclaimed NFTs\n\n",
        "remarks": "\n\nFetch all the NFTs that have been not been claimed yet in this Drop.\n\n*\n\n",
        "examples": {
          "javascript": "const unclaimedNFTs = await contract.getAllUnclaimed();\nconst firstUnclaimedNFT = unclaimedNFTs[0].name;"
        },
        "signature": "getAllUnclaimed(queryParams?: QueryAllParams): Promise<NFTMetadata[]>;"
      },
      {
        "name": "totalClaimedSupply",
        "summary": "Get the claimed supply\n\n",
        "remarks": "\n\nGet the number of claimed NFTs in this Drop.\n\n*\n\n",
        "examples": {
          "javascript": "const claimedNFTCount = await contract.totalClaimedSupply();\nconsole.log(`NFTs claimed so far: ${claimedNFTCount}`);"
        },
        "signature": "totalClaimedSupply(): Promise<BigNumber>;"
      },
      {
        "name": "totalUnclaimedSupply",
        "summary": "Get the unclaimed supply\n\n",
        "remarks": "\n\nGet the number of unclaimed NFTs in this Drop.\n\n*\n\n",
        "examples": {
          "javascript": "const unclaimedNFTCount = await contract.totalUnclaimedSupply();\nconsole.log(`NFTs left to claim: ${unclaimedNFTCount}`);"
        },
        "signature": "totalUnclaimedSupply(): Promise<BigNumber>;"
      }
    ],
    "signature": "declare class DropErc721Contract extends Erc721<DropERC721> "
  },
  "MarketplaceContract": {
    "name": "MarketplaceContract",
    "summary": "Create your own whitelabel marketplace that enables users to buy and sell any digital assets.\n\n",
    "remarks": null,
    "examples": {
      "javascript": "import { ThirdwebSDK } from \"@3rdweb/sdk\";\n\n// You can switch out this provider with any wallet or provider setup you like.\nconst provider = ethers.Wallet.createRandom();\nconst sdk = new ThirdwebSDK(provider);\nconst contract = sdk.getMarketplaceContract(\"{{contract_address}}\");"
    },
    "methods": [
      {
        "name": "buyoutAuctionListing",
        "summary": "Buyout Auction\n\n",
        "remarks": "\n\nBuy a specific direct listing from the marketplace.\n\n",
        "examples": {
          "javascript": "// The listing ID of the asset you want to buy\nconst listingId = 0;\n\nawait contract.buyoutAuctionListing(listingId);"
        },
        "signature": "buyoutAuctionListing(listingId: BigNumberish): Promise<TransactionResult>;"
      },
      {
        "name": "buyoutDirectListing",
        "summary": "Buy Listing\n\n",
        "remarks": "\n\nBuy a specific direct listing from the marketplace.\n\n",
        "examples": {
          "javascript": "// The listing ID of the asset you want to buy\nconst listingId = 0;\n// Quantity of the asset you want to buy\nconst quantityDesired = 1;\n\nawait contract.buyoutDirectListing(listingId, quantityDesired);"
        },
        "signature": "buyoutDirectListing(listingId: BigNumberish, quantityDesired: BigNumberish): Promise<TransactionResult>;"
      },
      {
        "name": "cancelAuctionListing",
        "summary": "Cancel Auction Listing\n\n",
        "remarks": "\n\nCancel an auction listing on the marketplace\n\n",
        "examples": {
          "javascript": "// The listing ID of the auction listing you want to cancel\nconst listingId = \"0\";\n\nawait contract.cancelAuctionListing(listingId);"
        },
        "signature": "cancelAuctionListing(listingId: BigNumberish): Promise<TransactionResult>;"
      },
      {
        "name": "cancelDirectListing",
        "summary": "Cancel Direct Listing\n\n",
        "remarks": "\n\nCancel a direct listing on the marketplace\n\n",
        "examples": {
          "javascript": "// The listing ID of the direct listing you want to cancel\nconst listingId = \"0\";\n\nawait contract.cancelDirectListing(listingId);"
        },
        "signature": "cancelDirectListing(listingId: BigNumberish): Promise<TransactionResult>;"
      },
      {
        "name": "closeAuctionListing",
        "summary": "Close the Auction\n\n",
        "remarks": "\n\nCloses the Auction and executes the sale.\n\n",
        "examples": {
          "javascript": "// The listing ID of the auction listing you want to close\nconst listingId = \"0\";\nawait closeAuctionListing(listindId);"
        },
        "signature": "closeAuctionListing(listingId: BigNumberish, closeFor?: string): Promise<TransactionResult>;"
      },
      {
        "name": "createAuctionListing",
        "summary": "Create Auction\n\n",
        "remarks": "\n\nCreate a new auction where people can bid on an asset.\n\n",
        "examples": {
          "javascript": "// Data of the auction you want to create\nconst auction = {\n  // address of the contract the asset you want to list is on\n  assetContractAddress: \"0x...\",\n  // token ID of the asset you want to list\n  tokenId: \"0\",\n  // in how many seconds with the listing open up\n  startTimeInSeconds: 0,\n  // how long the listing will be open for\n  listingDurationInSeconds: 86400,\n  // how many of the asset you want to list\n  quantity: 1,\n  // address of the currency contract that will be used to pay for the listing\n  currencyContractAddress: \"0x0000000000000000000000000000000000000000\",\n  // how much people would have to bid to instantly buy the asset\n  buyoutPricePerToken: \"10\",\n  // the minimum bid that will be accepted for the token\n  reservePricePerToken: \"1\",\n}\n\nconst tx = await contract.createAuctionListing(auction);\nconst receipt = tx.receipt; // the transaction receipt\nconst id = tx.id; // the id of the newly created listing"
        },
        "signature": "createAuctionListing(listing: NewAuctionListing): Promise<TransactionResultWithId>;"
      },
      {
        "name": "createDirectListing",
        "summary": "Create Direct Listing\n\n",
        "remarks": "\n\nCreate a new listing on the marketplace where people can buy an asset directly.\n\n",
        "examples": {
          "javascript": "// Data of the listing you want to create\nconst listing = {\n  // address of the contract the asset you want to list is on\n  assetContractAddress: \"0x...\",\n  // token ID of the asset you want to list\n  tokenId: \"0\",\n  // in how many seconds with the listing open up\n  startTimeInSeconds: 0,\n  // how long the listing will be open for\n  listingDurationInSeconds: 86400,\n  // how many of the asset you want to list\n  quantity: 1,\n  // address of the currency contract that will be used to pay for the listing\n  currencyContractAddress: \"0x0000000000000000000000000000000000000000\",\n  // how much the asset will be sold for\n  buyoutPricePerToken: \"1\",\n}\n\nconst tx = await contract.createDirectListing(listing);\nconst receipt = tx.receipt; // the transaction receipt\nconst id = tx.id; // the id of the newly created listing"
        },
        "signature": "createDirectListing(listing: NewDirectListing): Promise<TransactionResultWithId>;"
      },
      {
        "name": "getAuctionWinner",
        "summary": "Get Auction Winner\n\n",
        "remarks": "\n\nGet the winner of the auction after an auction ends.\n\n",
        "examples": {
          "javascript": "// The listing ID of the auction that closed\nconst listingId = 0;\n\ncontract\n  .getAuctionWinner(listingId)\n  .then((auctionWinner) => console.log(auctionWinner))\n  .catch((err) => console.error(err));"
        },
        "signature": "getAuctionWinner(listingId: BigNumberish): Promise<string>;"
      },
      {
        "name": "getWinningBid",
        "summary": "Get Highest Bid\n\n",
        "remarks": "\n\nGet the current highest bid of an active auction.\n\n",
        "examples": {
          "javascript": "// The listing ID of the auction that closed\nconst listingId = 0;\n\ncontract\n  .getWinningBid(listingId)\n  .then((offer) => console.log(offer))\n  .catch((err) => console.error(err));"
        },
        "signature": "getWinningBid(listingId: BigNumberish): Promise<Offer | undefined>;"
      },
      {
        "name": "makeAuctionListingBid",
        "summary": "Bid On Auction\n\n",
        "remarks": "\n\nMake a bid on an auction listings\n\n",
        "examples": {
          "javascript": "// The listing ID of the asset you want to bid on\nconst listingId = 0;\n// The price you are willing to bid for a single token of the listing\nconst pricePerToken = 1;\n\nawait contract.makeAuctionListingBid(listingId, pricePerToken);"
        },
        "signature": "makeAuctionListingBid(listingId: BigNumberish, pricePerToken: Price): Promise<TransactionResult>;"
      }
    ],
    "signature": "declare class MarketplaceContract implements UpdateableNetwork "
  },
  "PacksContract": {
    "name": "PacksContract",
    "summary": "Create lootboxes of NFTs with rarity based open mechanics.\n\n",
    "remarks": null,
    "examples": {
      "javascript": "import { ThirdwebSDK } from \"@3rdweb/sdk\";\n\n// You can switch out this provider with any wallet or provider setup you like.\nconst provider = ethers.Wallet.createRandom();\nconst sdk = new ThirdwebSDK(provider);\nconst contract = sdk.getPackContract(\"{{contract_address}}\");"
    },
    "methods": [
      {
        "name": "balanceOf",
        "summary": "Get Pack Balance\n\n",
        "remarks": "\n\nGet a wallets pack balance (number of a specific packs in this contract owned by the wallet).\n\n",
        "examples": {
          "javascript": "// Address of the wallet to check pack balance\nconst address = \"{{wallet_address}}\"\";\n// The token ID of the pack you want to check the wallets balance of\nconst tokenId = \"0\"\n\nconst balance = await contract.balanceOf(address, tokenId);\nconsole.log(balance);"
        },
        "signature": "balanceOf(address: string, tokenId: string): Promise<BigNumber>;"
      },
      {
        "name": "create",
        "summary": "Create Pack\n\n",
        "remarks": "\n\nCreate a new pack with its own rewards.\n\n",
        "examples": {
          "javascript": "// Data to create the pack\nconst pack = {\n  // The address of the contract that holds the rewards you want to include\n  assetContract: \"0x...\",\n  // The metadata of the pack\n  metadata: {\n    name: \"Cool Pack\",\n    description: \"This is a cool pack\",\n    // This can be an image url or image file\n    image: readFileSync(\"path/to/image.png\"),\n  },\n  // The NFTs you want to include in the pack\n  assets: [\n    {\n      tokenId: 0, // The token ID of the asset you want to add\n      amount: 1, // The amount of the asset you want to add\n    }, {\n      tokenId: 1,\n      amount: 1,\n    }\n  ],\n};\n\nawait contract.create(pack);"
        },
        "signature": "create(args: IPackCreateArgs): Promise<TransactionResultWithId<PackMetadata>>;"
      },
      {
        "name": "getAll",
        "summary": "Get Pack Data\n\n",
        "remarks": "\n\nGet data associated with every pack in this contract.\n\n",
        "examples": {
          "javascript": "const packs = await contract.getAll();\nconsole.log(packs);"
        },
        "signature": "getAll(): Promise<PackMetadata[]>;"
      },
      {
        "name": "getNFTs",
        "summary": "Get Pack Reward Data\n\n",
        "remarks": "\n\nGet data associated with the rewards inside a specified pack\n\n",
        "examples": {
          "javascript": "// The pack ID of the pack whos rewards you want to get\nconst packId = 0;\n\nconst nfts = await contract.getNFTs(packId);\nconsole.log(nfts);"
        },
        "signature": "getNFTs(packId: string): Promise<PackNFTMetadata[]>;"
      },
      {
        "name": "open",
        "summary": "Open Pack\n\n",
        "remarks": "\n\nOpen a pack to burn it and obtain the reward asset inside.\n\n",
        "examples": {
          "javascript": "// The pack ID of the asset you want to buy\nconst packId = \"0\";\nconst tx = await contract.open(packId);\nconst receipt = tx.receipt; // the transaction receipt\nconst packId = tx.id; // the id of the pack that was opened\nconst rewards = tx.data(); // the contents of the opened pack"
        },
        "signature": "open(packId: string): Promise<TransactionResultWithId<NFTMetadata>[]>;"
      },
      {
        "name": "transfer",
        "summary": "Transfer Pack\n\n",
        "remarks": "\n\nTransfer a pack from the connected wallet to another wallet.\n\n",
        "examples": {
          "javascript": "// Address of the wallet you want to send the pack to\nconst toAddress = \"0x...\";\n\n// The token ID of the pack you want to send\nconst tokenId = \"0\";\n\n// The number of packs you want to send\nconst amount = 1;\n\nawait contract.transfer(toAddress, tokenId, amount);"
        },
        "signature": "transfer(to: string, tokenId: string, amount: BigNumber): Promise<TransactionResult>;"
      }
    ],
    "signature": "declare class PacksContract implements UpdateableNetwork "
  },
  "SplitsContract": {
    "name": "SplitsContract",
    "summary": "Create custom royalty splits to distribute funds.\n\n",
    "remarks": null,
    "examples": {
      "javascript": "import { ThirdwebSDK } from \"@3rdweb/sdk\";\n\n// You can switch out this provider with any wallet or provider setup you like.\nconst provider = ethers.Wallet.createRandom();\nconst sdk = new ThirdwebSDK(provider);\nconst contract = sdk.getSplitsContract(\"{{contract_address}}\");"
    },
    "methods": [
      {
        "name": "balanceOf",
        "summary": "Get Funds owed to a particular wallet\n\n",
        "remarks": "\n\nGet the amount of funds in the native currency held by the contract thats owed to a specific recipient.\n\n",
        "examples": {
          "javascript": "// The address to check the funds of\nconst address = \"{{wallet_address}}\";\nconst funds = await contract.balanceOf(address);\nconsole.log(funds);"
        },
        "signature": "balanceOf(address: string): Promise<BigNumber>;"
      },
      {
        "name": "balanceOfToken",
        "summary": "Get non-native Token Funds owed to a particular wallet\n\n",
        "remarks": "\n\nGet the amount of funds in the non-native tokens held by the contract that is owed to a specific recipient.\n\n",
        "examples": {
          "javascript": "// The address to check the funds of\nconst address = \"{{wallet_address}}\";\n// The address of the currency to check the contracts funds of\nconst tokenAddress = \"0x...\"\nconst funds = await contract.balanceOfToken(address, tokenAddress);\nconsole.log(funds);"
        },
        "signature": "balanceOfToken(walletAddress: string, tokenAddress: string): Promise<CurrencyValue>;"
      },
      {
        "name": "distribute",
        "summary": "Distribute Funds\n\n",
        "remarks": "\n\nDistribute funds held by the contract in the native currency to all recipients.\n\n",
        "examples": {
          "javascript": "await contract.distribute();"
        },
        "signature": "distribute(): Promise<TransactionResult>;"
      },
      {
        "name": "distributeToken",
        "summary": "Distribute Funds\n\n",
        "remarks": "\n\nDistribute funds held by the contract in the native currency to all recipients.\n\n",
        "examples": {
          "javascript": "// The address of the currency to distribute funds\nconst tokenAddress = \"0x...\"\nawait contract.distributeToken(tokenAddress);"
        },
        "signature": "distributeToken(tokenAddress: string): Promise<TransactionResult>;"
      },
      {
        "name": "getAllRecipients",
        "summary": "Get Recipients of this splits contract\n\n",
        "remarks": "\n\nGet the data about the shares of every split recipient on the contract\n\n",
        "examples": {
          "javascript": "const recipients = await contract.getAllRecipients();\nconsole.log(recipients);"
        },
        "signature": "getAllRecipients(): Promise<SplitRecipient[]>;"
      }
    ],
    "signature": "declare class SplitsContract implements UpdateableNetwork "
  },
  "TokenErc1155Contract": {
    "name": "TokenErc1155Contract",
    "summary": "Setup a collection of one-of-one NFTs that are minted as users claim them.\n\n",
    "remarks": null,
    "examples": {
      "javascript": "import { ThirdwebSDK } from \"@3rdweb/sdk\";\n\n// You can switch out this provider with any wallet or provider setup you like.\nconst provider = ethers.Wallet.createRandom();\nconst sdk = new ThirdwebSDK(provider);\nconst contract = sdk.getBundleContract(\"{{contract_address}}\");"
    },
    "methods": [
      {
        "name": "mintBatchTo",
        "summary": "Mint Many NFTs with limited supplies\n\n",
        "remarks": "\n\nMint many different NFTs with limited supplies to a specified wallet.\n\n",
        "examples": {
          "javascript": "// Address of the wallet you want to mint the NFT to\nconst toAddress = \"{{wallet_address}}\"\n\n// Custom metadata and supplies of your NFTs\nconst metadataWithSupply = [{\n  supply: 50, // The number of this NFT you want to mint\n  metadata: {\n    name: \"Cool NFT #1\",\n    description: \"This is a cool NFT\",\n    image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n  },\n}, {\n  supply: 100,\n  metadata: {\n    name: \"Cool NFT #2\",\n    description: \"This is a cool NFT\",\n    image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n  },\n}];\n\nconst tx = await contract.mintBatchTo(toAddress, metadataWithSupply);\nconst receipt = tx[0].receipt; // same transaction receipt for all minted NFTs\nconst tokenIds = tx.map((result) => result.id); // all the token ids minted\nconst firstTokenId = tx[0].id; // token id of the first minted NFT\nconst firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT"
        },
        "signature": "mintBatchTo(to: string, metadataWithSupply: BundleMetadataInput[]): Promise<TransactionResultWithId<BundleMetadata>[]>;"
      },
      {
        "name": "mintTo",
        "summary": "Mint an NFT with a limited supply\n\n",
        "remarks": "\n\nMint an NFT with a limited supply to a specified wallet.\n\n",
        "examples": {
          "javascript": "// Address of the wallet you want to mint the NFT to\nconst toAddress = \"{{wallet_address}}\"\n\n// Custom metadata of the NFT, note that you can fully customize this metadata with other properties.\nconst metadata = {\n  name: \"Cool NFT\",\n  description: \"This is a cool NFT\",\n  image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n}\n\nconst metadataWithSupply = {\n  metadata,\n  supply: 1000, // The number of this NFT you want to mint\n}\n\nconst tx = await contract.mintTo(toAddress, metadataWithSupply);\nconst receipt = tx.receipt; // the transaction receipt\nconst tokenId = tx.id; // the id of the NFT minted\nconst nft = await tx.data(); // (optional) fetch details of minted NFT"
        },
        "signature": "mintTo(to: string, metadataWithSupply: BundleMetadataInput): Promise<TransactionResultWithId<BundleMetadata>>;"
      }
    ],
    "signature": "declare class TokenErc1155Contract extends Erc1155<TokenERC1155> "
  },
  "TokenErc20Contract": {
    "name": "TokenErc20Contract",
    "summary": "Create a standard crypto token or crypto currency.\n\n",
    "remarks": null,
    "examples": {
      "javascript": "import { ThirdwebSDK } from \"@3rdweb/sdk\";\n\n// You can switch out this provider with any wallet or provider setup you like.\nconst provider = ethers.Wallet.createRandom();\nconst sdk = new ThirdwebSDK(provider);\nconst contract = sdk.getTokenContract(\"{{contract_address}}\");"
    },
    "methods": [
      {
        "name": "mintBatchTo",
        "summary": "Mint Tokens To Many Wallets\n\n",
        "remarks": "\n\nMint tokens to many wallets in one transaction.\n\n",
        "examples": {
          "javascript": "// Data of the tokens you want to mint\nconst data = [\n  {\n    toAddress: \"{{wallet_address}}\", // Address to mint tokens to\n    amount: 100, // How many tokens to mint to specified address\n  },\n {\n   toAddress: \"0x...\",\n   amount: 100,\n }\n]\n\nawait contract.mintBatchTo(data);"
        },
        "signature": "mintBatchTo(args: TokenMintInput[]): Promise<TransactionResult>;"
      },
      {
        "name": "mintTo",
        "summary": "Mint Tokens\n\n",
        "remarks": "\n\nMint tokens to a specified address.\n\n",
        "examples": {
          "javascript": "const toAddress = \"{{wallet_address}}\"; // Address of the wallet you want to mint the tokens to\nconst amount = \"1.5\"; // The amount of this token you want to mint\n\nawait contract.mintTo(toAddress, amount);"
        },
        "signature": "mintTo(to: string, amount: BigNumberish): Promise<TransactionResult>;"
      }
    ],
    "signature": "declare class TokenErc20Contract extends Erc20<TokenERC20> "
  },
  "TokenErc721Contract": {
    "name": "TokenErc721Contract",
    "summary": "Create a collection of one-of-one NFTs.\n\n",
    "remarks": null,
    "examples": {
      "javascript": "import { ThirdwebSDK } from \"@3rdweb/sdk\";\n\n// You can switch out this provider with any wallet or provider setup you like.\nconst provider = ethers.Wallet.createRandom();\nconst sdk = new ThirdwebSDK(provider);\nconst contract = sdk.getNFTContract(\"{{contract_address}}\");"
    },
    "methods": [
      {
        "name": "generateSignature",
        "summary": "Generate a signature that can be used to mint a dynamic NFT\n\n",
        "remarks": "\n\nTakes in an NFT and some information about how it can be minted, uploads the metadata and signs it with your private key. The generated signature can then be used to mint an NFT using the exact payload and signature generated.\n\n",
        "examples": {
          "javascript": "const nftMetadata = {\n  name: \"Cool NFT #1\",\n  description: \"This is a cool NFT\",\n  image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n};\n\nconst now = Math.floor(Date.now() / 1000);\nconst payload = {\n  metadta: nftMetadata, // The NFT to mint\n  to: {{wallet_address}}, // Who will receive the NFT (or AddressZero for anyone)\n  price: 0.5, // the price to pay for minting\n  currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with\n  mintStartTimeEpochSeconds: now, // can mint anytime from now\n  mintEndTimeEpochSeconds: now + 60 * 60 * 24 * 7, // to 24h from now\n};\n\nconst { mintRequest, signature } = contract.generateSignature(payload);\n// now anynone can use these to mint the NFT using `mintWithSignature()`"
        },
        "signature": "generateSignature(mintRequest: NewSignaturePayload): Promise<{\n        payload: SignaturePayload;\n        signature: string;\n    }>;"
      },
      {
        "name": "mintBatchTo",
        "summary": "Mint Many unique NFTs\n\n",
        "remarks": "\n\nMint many unique NFTs at once to a specified wallet.\n\n",
        "examples": {
          "javascript": "// Address of the wallet you want to mint the NFT to\nconst toAddress = \"{{wallet_address}}\";\n\n// Custom metadata of the NFTs you want to mint.\nconst metadatas = [{\n  name: \"Cool NFT #1\",\n  description: \"This is a cool NFT\",\n  image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n}, {\n  name: \"Cool NFT #2\",\n  description: \"This is a cool NFT\",\n  image: fs.readFileSync(\"path/to/other/image.png\"),\n}];\n\nconst tx = await contract.mintBatchTo(toAddress, metadatas);\nconst receipt = tx[0].receipt; // same transaction receipt for all minted NFTs\nconst firstTokenId = tx[0].id; // token id of the first minted NFT\nconst firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT"
        },
        "signature": "mintBatchTo(to: string, metadatas: NFTMetadataInput[]): Promise<TransactionResultWithId<NFTMetadataOwner>[]>;"
      },
      {
        "name": "mintTo",
        "summary": "Mint a unique NFT\n\n",
        "remarks": "\n\nMint a unique NFT to a specified wallet.\n\n",
        "examples": {
          "javascript": "// Address of the wallet you want to mint the NFT to\nconst toAddress = \"{{wallet_address}}\";\n\n// Custom metadata of the NFT, note that you can fully customize this metadata with other properties.\nconst metadata = {\n  name: \"Cool NFT\",\n  description: \"This is a cool NFT\",\n  image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n};\n\nconst tx = await contract.mintTo(toAddress, metadata);\nconst receipt = tx.receipt; // the transaction receipt\nconst tokenId = tx.id; // the id of the NFT minted\nconst nft = await tx.data(); // (optional) fetch details of minted NFT"
        },
        "signature": "mintTo(to: string, metadata: NFTMetadataInput): Promise<TransactionResultWithId<NFTMetadataOwner>>;"
      },
      {
        "name": "mintWithSignature",
        "summary": "Mint a dynamicly generated NFT\n\n",
        "remarks": "\n\nMint an dynamic NFT with a previously generated signature.\n\n",
        "examples": {
          "javascript": "// see how to craft a payload to sign in the `generateSignature()` documentation\nconst { mintRequest, signature } = contract.generateSignature(payload);\n\n// now anyone can mint the NFT\nconst tx = contract.mintWithSignature(mintRequest, signature);\nconst receipt = tx.receipt; // the mint transaction receipt\nconst mintedId = tx.id; // the id of the NFT minted\nconst mintedNFT = await tx.data(); // (optional) fetch the details of the minted NFT"
        },
        "signature": "mintWithSignature(mintRequest: SignaturePayload, signature: string): Promise<TransactionResultWithId<NFTMetadataOwner>>;"
      }
    ],
    "signature": "declare class TokenErc721Contract extends Erc721<TokenERC721> "
  },
  "VoteContract": {
    "name": "VoteContract",
    "summary": "Create a decentralized organization for token holders to vote on proposals.\n\n",
    "remarks": null,
    "examples": {
      "javascript": "import { ThirdwebSDK } from \"@3rdweb/sdk\";\n\n// You can switch out this provider with any wallet or provider setup you like.\nconst provider = ethers.Wallet.createRandom();\nconst sdk = new ThirdwebSDK(provider);\nconst contract = sdk.getVoteContract(\"{{contract_address}}\");"
    },
    "methods": [
      {
        "name": "canExecute",
        "summary": "Can Execute\n\n",
        "remarks": "\n\nCheck if a proposal can be executed (if the proposal has succeeded).\n\n",
        "examples": {
          "javascript": "// The proposal ID of the proposal you want to check\nconst proposalId = \"0\";\nconst canExecute = await contract.canExecute(proposalId);\nconsole.log(canExecute);"
        },
        "signature": "canExecute(proposalId: string): Promise<boolean>;"
      },
      {
        "name": "execute",
        "summary": "Execute Proposal\n\n",
        "remarks": "\n\nExecute the related transactions for a proposal if the proposal succeeded.\n\n",
        "examples": {
          "javascript": "// The proposal ID ofthe proposal you want to execute\nconst proposalId = \"0\"\nawait contract.execute(proposalId);"
        },
        "signature": "execute(proposalId: string): Promise<TransactionResult>;"
      },
      {
        "name": "getAll",
        "summary": "Get All Proposals\n\n",
        "remarks": "\n\nGet all the proposals in this contract.\n\n",
        "examples": {
          "javascript": "const proposals = await contract.getAll();\nconsole.log(proposals);"
        },
        "signature": "getAll(): Promise<Proposal[]>;"
      },
      {
        "name": "hasVoted",
        "summary": "Check If Wallet Voted\n\n",
        "remarks": "\n\nCheck if a specified wallet has voted a specific proposal\n\n",
        "examples": {
          "javascript": "// The proposal ID of the proposal you want to check\nconst proposalId = \"0\";\n// The address of the wallet you want to check to see if they voted\nconst address = \"{{wallet_address}}\";\n\nawait contract.hasVoted(proposalId, address);"
        },
        "signature": "hasVoted(proposalId: string, account?: string): Promise<boolean>;"
      },
      {
        "name": "propose",
        "summary": "Create Proposal\n\n",
        "remarks": "\n\nCreate a new proposal for token holders to vote on.\n\n",
        "examples": {
          "javascript": "// The description of the proposal you want to pass\nconst description = \"This is a great proposal - vote for it!\"\n// You can (optionally) pass in contract calls that will get executed when the proposal is executed.\nconst executions = [\n  {\n    // The contract you want to make a call to\n    toAddress: \"0x...\",\n    // The amount of the native currency to send in this transaction\n    nativeTokenValue: 0,\n    // Transaction data that will be executed when the proposal is executed\n    // This is an example transfer transaction with a token contract (which you would need to setup in code)\n    transactionData: tokenContract.encoder.encode(\n      \"transfer\", [\n        fromAddress,\n        amount,\n      ]\n    ),\n  }\n]\n\nconst proposal = await contract.propose(description, executions);"
        },
        "signature": "propose(description: string, executions?: ProposalExecutable[]): Promise<TransactionResultWithId>;"
      },
      {
        "name": "vote",
        "summary": "Vote\n\n",
        "remarks": "\n\nVote on an active proposal\n\n",
        "examples": {
          "javascript": "// The proposal ID of the proposal you want to vote on\nconst proposalId = \"0\";\n// The vote type you want to cast, can be VoteType.Against, VoteType.For, or VoteType.Abstain\nconst voteType = VoteType.For;\n// The (optional) reason for the vote\nconst reason = \"I like this proposal!\";\n\nawait contract.vote(proposalId, voteType, reason);"
        },
        "signature": "vote(proposalId: string, voteType: VoteType, reason?: string): Promise<TransactionResult>;"
      }
    ],
    "signature": "declare class VoteContract implements UpdateableNetwork "
  }
}